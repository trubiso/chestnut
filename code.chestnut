class Tuple<A, B> {}
class GridPiece {}
class Array<T> {}

/*
void print_position(Tuple<i32[]&, i32?>[3]?& position) pure {}

void print_grid(GridPiece&[3][4]?[] pieces) {}
*/

void silly() {

}

void set_error_callback() {

}

export void set_element() mut {

}

void takes_in_function<T>() {
	
}

// i128 proxy(i128() x) {
// 	return x();
// }

class Node<T> {
	Node<T>& next;
	public T value;

	public void traverse() {
		let x = 9;
	}

	public void set() mut {

	}
}

T add<T, T>(T a, T b) pure => a + b;

i32 do_thing(i32 only_arg) {
	// let u = proxy(() => 2);
	let a = only_arg;
	let b = 10;
	let c = a + b;
	let d = a * c;
	let e = a + b + c + d + 1 + 2 + 3 + 4 + 5;
	return e;
}

void test() {
	~& x;
	u32& y = x;
}

i128 lets_return_a_reference() {
	~x;
	return x;
}

T dbg<T>(T item) {
	unsafe {
		cpp "std::cout << Chn_item << std::endl;";
	}
	return item;
}

Node<T> sam<T, U>(T x, U y) {

}

T extract<T>(Node<T> x) {

}

i32 get_an_int() => 5;

T get_back<T>(T value) => value;

void get_an_int_test() {
	let get_an_int_test_variable = get_an_int();
	let get_back_test_variable = get_back("hi");
}

void main() {
	takes_in_function<void(void())>();
	// print_position(3);
	// let ~ = do_thing();
	mut char t;
	/*unsafe {
		t = 10;
	}*/
	t = t;
	mut i32 d;
	// d.value;
	// TODO: infer these int types
	u16 x = 2u16 + (3u16 - 4u16);
	~ iw;
	iw = add(x, x);
	let long_name_so_i_can_find_it_in_the_debugger = add<~, u64>(x, x);
	mut a = 3 + 5 + (2 - 3) * -9 + 4/2;
	a += 10;
	a *= 9 + 10;
	Node bob = sam(3, 4);
	let boom = extract(bob);
	Node<~> u;
	Tuple<~> not_enough;
	Tuple<~, ~, ~> too_many;
	let cvxjnk = dbg(-10);
	4+2+4;
	.3u + (0xDead_Beefu - 2iz) - 7u32 * 0b1010_1001i128 / 0o7f;

	mut r = 10;



	let aa = 'a';
	// 3 + a(); -> error

	void goofy_void() {

	}

	let b = 'b';
	let cc = 'c';

	// a + b(); -> error

	// (string err) => print(err);
}
